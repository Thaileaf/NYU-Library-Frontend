{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport inRange from 'lodash/inRange';\nimport XDate from 'xdate';\nimport constants from \"../commons/constants\";\nexport var HOUR_BLOCK_HEIGHT = 100;\nvar OVERLAP_EVENTS_SPACINGS = 10;\nvar RIGHT_EDGE_SPACING = 10;\nfunction buildEvent(event, left, width, _ref) {\n  var _ref$dayStart = _ref.dayStart,\n    dayStart = _ref$dayStart === void 0 ? 0 : _ref$dayStart,\n    _ref$hourBlockHeight = _ref.hourBlockHeight,\n    hourBlockHeight = _ref$hourBlockHeight === void 0 ? HOUR_BLOCK_HEIGHT : _ref$hourBlockHeight;\n  var startTime = new XDate(event.start);\n  var endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n  var dayStartTime = new XDate(startTime).clearTime();\n  return _objectSpread(_objectSpread({}, event), {}, {\n    top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n    height: startTime.diffHours(endTime) * hourBlockHeight,\n    width: width,\n    left: left\n  });\n}\nfunction hasCollision(a, b) {\n  return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n  var colSpan = 1;\n  for (var i = columnIndex + 1; i < columns.length; i++) {\n    var column = columns[i];\n    var foundCollision = column.find(function (ev) {\n      return hasCollision(event, ev);\n    });\n    if (foundCollision) {\n      return colSpan;\n    }\n    colSpan++;\n  }\n  return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n  var _populateOptions$scre = populateOptions.screenWidth,\n    screenWidth = _populateOptions$scre === void 0 ? constants.screenWidth : _populateOptions$scre,\n    _populateOptions$righ = populateOptions.rightEdgeSpacing,\n    rightEdgeSpacing = _populateOptions$righ === void 0 ? RIGHT_EDGE_SPACING : _populateOptions$righ,\n    _populateOptions$over = populateOptions.overlapEventsSpacing,\n    overlapEventsSpacing = _populateOptions$over === void 0 ? OVERLAP_EVENTS_SPACINGS : _populateOptions$over;\n  columns.forEach(function (column, columnIndex) {\n    column.forEach(function (event) {\n      var totalWidth = screenWidth - rightEdgeSpacing;\n      var columnSpan = calcColumnSpan(event, columnIndex, columns);\n      var eventLeft = columnIndex / columns.length * totalWidth;\n      var eventWidth = totalWidth * (columnSpan / columns.length);\n      if (columnIndex + columnSpan <= columns.length - 1) {\n        eventWidth -= overlapEventsSpacing;\n      }\n      calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n    });\n  });\n}\nexport function populateEvents(_events, populateOptions) {\n  var lastEnd = null;\n  var columns = [];\n  var calculatedEvents = [];\n  var events = _events.map(function (ev, index) {\n    return _objectSpread(_objectSpread({}, ev), {}, {\n      index: index\n    });\n  }).sort(function (a, b) {\n    if (a.start < b.start) return -1;\n    if (a.start > b.start) return 1;\n    if (a.end < b.end) return -1;\n    if (a.end > b.end) return 1;\n    return 0;\n  });\n  events.forEach(function (ev) {\n    if (lastEnd !== null && ev.start >= lastEnd) {\n      packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n      columns = [];\n      lastEnd = null;\n    }\n    var placed = false;\n    for (var i = 0; i < columns.length; i++) {\n      var col = columns[i];\n      if (!hasCollision(col[col.length - 1], ev)) {\n        col.push(ev);\n        placed = true;\n        break;\n      }\n    }\n    if (!placed) {\n      columns.push([ev]);\n    }\n    if (lastEnd === null || ev.end > lastEnd) {\n      lastEnd = ev.end;\n    }\n  });\n  if (columns.length > 0) {\n    packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n  }\n  return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks() {\n  var unavailableHours = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 ? arguments[1] : undefined;\n  var _ref2 = options || {},\n    _ref2$hourBlockHeight = _ref2.hourBlockHeight,\n    hourBlockHeight = _ref2$hourBlockHeight === void 0 ? HOUR_BLOCK_HEIGHT : _ref2$hourBlockHeight,\n    _ref2$dayStart = _ref2.dayStart,\n    dayStart = _ref2$dayStart === void 0 ? 0 : _ref2$dayStart,\n    _ref2$dayEnd = _ref2.dayEnd,\n    dayEnd = _ref2$dayEnd === void 0 ? 24 : _ref2$dayEnd;\n  var totalDayHours = dayEnd - dayStart;\n  var totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n  return unavailableHours.map(function (hours) {\n    if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n      console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n      return undefined;\n    }\n    if (hours.start >= hours.end) {\n      console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n      return undefined;\n    }\n    var startFixed = Math.max(hours.start, dayStart);\n    var endFixed = Math.min(hours.end, dayEnd);\n    return {\n      top: (startFixed - dayStart) / totalDayHours * totalDayHeight,\n      height: (endFixed - startFixed) * hourBlockHeight\n    };\n  }).filter(Boolean);\n}","map":{"version":3,"names":["inRange","XDate","constants","HOUR_BLOCK_HEIGHT","OVERLAP_EVENTS_SPACINGS","RIGHT_EDGE_SPACING","buildEvent","event","left","width","_ref","_ref$dayStart","dayStart","_ref$hourBlockHeight","hourBlockHeight","startTime","start","endTime","end","addHours","dayStartTime","clearTime","_objectSpread","top","diffHours","height","hasCollision","a","b","calcColumnSpan","columnIndex","columns","colSpan","i","length","column","foundCollision","find","ev","packOverlappingEventGroup","calculatedEvents","populateOptions","_populateOptions$scre","screenWidth","_populateOptions$righ","rightEdgeSpacing","_populateOptions$over","overlapEventsSpacing","forEach","totalWidth","columnSpan","eventLeft","eventWidth","push","populateEvents","_events","lastEnd","events","map","index","sort","placed","col","buildUnavailableHoursBlocks","unavailableHours","arguments","undefined","options","_ref2","_ref2$hourBlockHeight","_ref2$dayStart","_ref2$dayEnd","dayEnd","totalDayHours","totalDayHeight","hours","console","error","startFixed","Math","max","endFixed","min","filter","Boolean"],"sources":["C:/Users/letha/WebstormProjects/NYU-Library-Frontend/node_modules/react-native-calendars/src/timeline/Packer.js"],"sourcesContent":["import inRange from 'lodash/inRange';\nimport XDate from 'xdate';\nimport constants from '../commons/constants';\nexport const HOUR_BLOCK_HEIGHT = 100;\nconst OVERLAP_EVENTS_SPACINGS = 10;\nconst RIGHT_EDGE_SPACING = 10;\nfunction buildEvent(event, left, width, { dayStart = 0, hourBlockHeight = HOUR_BLOCK_HEIGHT }) {\n    const startTime = new XDate(event.start);\n    const endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n    const dayStartTime = new XDate(startTime).clearTime();\n    return {\n        ...event,\n        top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n        height: startTime.diffHours(endTime) * hourBlockHeight,\n        width,\n        left\n    };\n}\nfunction hasCollision(a, b) {\n    return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n    let colSpan = 1;\n    for (let i = columnIndex + 1; i < columns.length; i++) {\n        const column = columns[i];\n        const foundCollision = column.find(ev => hasCollision(event, ev));\n        if (foundCollision) {\n            return colSpan;\n        }\n        colSpan++;\n    }\n    return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n    const { screenWidth = constants.screenWidth, rightEdgeSpacing = RIGHT_EDGE_SPACING, overlapEventsSpacing = OVERLAP_EVENTS_SPACINGS } = populateOptions;\n    columns.forEach((column, columnIndex) => {\n        column.forEach(event => {\n            const totalWidth = screenWidth - rightEdgeSpacing;\n            const columnSpan = calcColumnSpan(event, columnIndex, columns);\n            const eventLeft = (columnIndex / columns.length) * totalWidth;\n            let eventWidth = totalWidth * (columnSpan / columns.length);\n            if (columnIndex + columnSpan <= columns.length - 1) {\n                eventWidth -= overlapEventsSpacing;\n            }\n            calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n        });\n    });\n}\nexport function populateEvents(_events, populateOptions) {\n    let lastEnd = null;\n    let columns = [];\n    const calculatedEvents = [];\n    const events = _events\n        .map((ev, index) => ({ ...ev, index: index }))\n        .sort(function (a, b) {\n        if (a.start < b.start)\n            return -1;\n        if (a.start > b.start)\n            return 1;\n        if (a.end < b.end)\n            return -1;\n        if (a.end > b.end)\n            return 1;\n        return 0;\n    });\n    events.forEach(function (ev) {\n        // Reset recent overlapping event group and start a new one\n        if (lastEnd !== null && ev.start >= lastEnd) {\n            packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n            columns = [];\n            lastEnd = null;\n        }\n        // Place current event in the right column where it doesn't overlap\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (!hasCollision(col[col.length - 1], ev)) {\n                col.push(ev);\n                placed = true;\n                break;\n            }\n        }\n        // If curr event wasn't placed in any of the columns, create a new column for it\n        if (!placed) {\n            columns.push([ev]);\n        }\n        if (lastEnd === null || ev.end > lastEnd) {\n            lastEnd = ev.end;\n        }\n    });\n    if (columns.length > 0) {\n        packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n    }\n    return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks(unavailableHours = [], options) {\n    const { hourBlockHeight = HOUR_BLOCK_HEIGHT, dayStart = 0, dayEnd = 24 } = options || {};\n    const totalDayHours = dayEnd - dayStart;\n    const totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n    return (unavailableHours\n        .map(hours => {\n        if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n            console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n            return undefined;\n        }\n        if (hours.start >= hours.end) {\n            console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n            return undefined;\n        }\n        const startFixed = Math.max(hours.start, dayStart);\n        const endFixed = Math.min(hours.end, dayEnd);\n        return {\n            top: ((startFixed - dayStart) / totalDayHours) * totalDayHeight,\n            height: (endFixed - startFixed) * hourBlockHeight\n        };\n    })\n        // Note: this filter falsy values (undefined blocks)\n        .filter(Boolean));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}